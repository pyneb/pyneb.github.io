
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyneb package &#8212; PyNEB  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="pyneb-package">
<h1>pyneb package<a class="headerlink" href="#pyneb-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyneb.fileio">
<span id="pyneb-fileio-module"></span><h2>pyneb.fileio module<a class="headerlink" href="#module-pyneb.fileio" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.DPMLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">DPMLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classInst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.DPMLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.DPMLogger.finalize">
<span class="sig-name descname"><span class="pre">finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minPathDict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minIndsDict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distsDict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">runTime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathAsText</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.DPMLogger.finalize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.DPMLogger.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">previousIndsArr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distArr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">updateRange</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.DPMLogger.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.DijkstraLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">DijkstraLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">djkInst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.DijkstraLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.DijkstraLogger.finalize">
<span class="sig-name descname"><span class="pre">finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">runTime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathAsText</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.DijkstraLogger.finalize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.DijkstraLogger.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variableNames</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.DijkstraLogger.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.ForceLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">ForceLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classInst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loggerSettings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileExt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.ForceLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.ForceLogger.flush">
<span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.ForceLogger.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Note that this must be called, as the self.log only writes the data in
chunks. Any data falling outside of those chunks will be stored in
self.logDict, but not written.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variables</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>variableNames</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.ForceLogger.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variablesDict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.ForceLogger.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.ForceLogger.write_early_stop_params">
<span class="sig-name descname"><span class="pre">write_early_stop_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">earlyStopParams</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.ForceLogger.write_early_stop_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.ForceLogger.write_fire_params">
<span class="sig-name descname"><span class="pre">write_fire_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsSinceReset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fireParams</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.ForceLogger.write_fire_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.fileio.ForceLogger.write_runtime">
<span class="sig-name descname"><span class="pre">write_runtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">runTime</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.ForceLogger.write_runtime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.LoadDPMLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">LoadDPMLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fName</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.LoadDPMLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.LoadDijkstraLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">LoadDijkstraLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.LoadDijkstraLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.LoadForceLog">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">LoadForceLog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.LoadForceLog" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyneb.fileio.LoadForceLogger" title="pyneb.fileio.LoadForceLogger"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyneb.fileio.LoadForceLogger</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.LoadForceLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">LoadForceLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.LoadForceLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.NDInterpLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">NDInterpLogger</span></span><a class="headerlink" href="#pyneb.fileio.NDInterpLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.fileio.VerletLogger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">VerletLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vltInst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.VerletLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.fileio.path_from_text">
<span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">path_from_text</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnHeads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.path_from_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.fileio.path_to_text">
<span class="sig-prename descclassname"><span class="pre">pyneb.fileio.</span></span><span class="sig-name descname"><span class="pre">path_to_text</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colHeads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.fileio.path_to_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyneb.solvers">
<span id="pyneb-solvers-module"></span><h2>pyneb.solvers module<a class="headerlink" href="#module-pyneb.solvers" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyneb.solvers.Dijkstra">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.solvers.</span></span><span class="sig-name descname"><span class="pre">Dijkstra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initialPoint,</span> <span class="pre">coordMeshTuple,</span> <span class="pre">potArr,</span> <span class="pre">inertArr=None,</span> <span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;,</span> <span class="pre">allowedEndpoints=None,</span> <span class="pre">trimVals=[0.0001,</span> <span class="pre">None],</span> <span class="pre">logLevel=1,</span> <span class="pre">fName=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.Dijkstra" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.Dijkstra.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initialPoint,</span> <span class="pre">coordMeshTuple,</span> <span class="pre">potArr,</span> <span class="pre">inertArr=None,</span> <span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;,</span> <span class="pre">allowedEndpoints=None,</span> <span class="pre">trimVals=[0.0001,</span> <span class="pre">None],</span> <span class="pre">logLevel=1,</span> <span class="pre">fName=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.Dijkstra.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Some indexing is done to deal with the default shape of np.meshgrid.
For D dimensions, the output is of shape (N2,N1,N3,…,ND), while the
way indices are generated expects a shape of (N1,…,ND). So, I swap
the first two indices by hand. See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html">https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html</a>
#TODO: error handling (try getting an index)(?)</p>
<p>Note that indexing for Dijkstra <em>internal</em> functions are done in the
order (N2,N1,N3,…), for simplicity. The indexing that is returned
by self.__call__ is kept in this order by default.</p>
<p>Note that the <em>value</em> of the array at a certain index is the same
regardless of the sort order of the indices, provided that the index
order matches that used when creating np.meshgrid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initialPoint</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>coordMeshTuple</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>potArr</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>inertArr</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is None.</p></li>
<li><p><strong>target_func</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is action.</p></li>
<li><p><strong>allowedEndpoints</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is None.</p></li>
<li><p><strong>trimVals</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is [10**(-4),None].</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.Dijkstra.minimum_endpoint">
<span class="sig-name descname"><span class="pre">minimum_endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distanceDict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.Dijkstra.minimum_endpoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.solvers.DynamicProgramming">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.solvers.</span></span><span class="sig-name descname"><span class="pre">DynamicProgramming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initialPoint,</span> <span class="pre">coordMeshTuple,</span> <span class="pre">potArr,</span> <span class="pre">inertArr=None,</span> <span class="pre">allowedMask=None,</span> <span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;,</span> <span class="pre">allowedEndpoints=None,</span> <span class="pre">trimVals=[0.0001,</span> <span class="pre">None],</span> <span class="pre">logLevel=1,</span> <span class="pre">fName=None,</span> <span class="pre">logFreq=50</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.DynamicProgramming" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.DynamicProgramming.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initialPoint,</span> <span class="pre">coordMeshTuple,</span> <span class="pre">potArr,</span> <span class="pre">inertArr=None,</span> <span class="pre">allowedMask=None,</span> <span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;,</span> <span class="pre">allowedEndpoints=None,</span> <span class="pre">trimVals=[0.0001,</span> <span class="pre">None],</span> <span class="pre">logLevel=1,</span> <span class="pre">fName=None,</span> <span class="pre">logFreq=50</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.DynamicProgramming.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.solvers.EulerLagrangeSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.solvers.</span></span><span class="sig-name descname"><span class="pre">EulerLagrangeSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initialPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass_func=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_approx=&lt;function</span> <span class="pre">midpoint_grad&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.EulerLagrangeSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.EulerLagrangeSolver.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initialPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass_func=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_approx=&lt;function</span> <span class="pre">midpoint_grad&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.EulerLagrangeSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.EulerLagrangeSolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.EulerLagrangeSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.solvers.EulerLagrangeVerifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.solvers.</span></span><span class="sig-name descname"><span class="pre">EulerLagrangeVerifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass_func=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_approx=&lt;function</span> <span class="pre">midpoint_grad&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.EulerLagrangeVerifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.EulerLagrangeVerifier.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass_func=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_approx=&lt;function</span> <span class="pre">midpoint_grad&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.EulerLagrangeVerifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>eneg_func</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>mass_func</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is None.</p></li>
<li><p><strong>grad_approx</strong> (<em>Function</em><em>, </em><em>optional</em>) – For computing gradients of the potential and inertia tensor.
The default is midpoint_grad.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.EulerLagrangeVerifier.compare_lagrangian">
<span class="sig-name descname"><span class="pre">compare_lagrangian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nPts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.EulerLagrangeVerifier.compare_lagrangian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.EulerLagrangeVerifier.compare_lagrangian_squared">
<span class="sig-name descname"><span class="pre">compare_lagrangian_squared</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.EulerLagrangeVerifier.compare_lagrangian_squared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.solvers.</span></span><span class="sig-name descname"><span class="pre">LeastActionPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nPts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nDims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointSpringForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointHarmonicForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func_grad=&lt;bound</span> <span class="pre">method</span> <span class="pre">GradientApproximations.forward_action_grad</span> <span class="pre">of</span> <span class="pre">&lt;utilities.GradientApproximations</span> <span class="pre">object&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nebParams={}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loggerSettings={}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.LeastActionPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Computes the net force on a band, when minimizing an action-type functional,
of the form</p>
<p>$$ S = int_{s_0}^{s_1} sqrt{2 M_{ij}dot{x}_idot{x}_j E(x(s))} ds. $$</p>
<p>Can be generalized to functionals of the form</p>
<p>$$ S = int_{s_0}^{s_1} f(s) ds $$</p>
<p>by choosing target_func differently. A common example is minimizing</p>
<p>$$ S = int_{s_0}^{s_1} M_{ij}dot{x}_idot{x}_j E(x(s)) ds, $$</p>
<p>with no square root inside of the integral.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.potential">
<span class="sig-name descname"><span class="pre">potential</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the energy along the path</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.nPts">
<span class="sig-name descname"><span class="pre">nPts</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.nPts" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of images in the path (path.shape[0])</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.nDims">
<span class="sig-name descname"><span class="pre">nDims</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.nDims" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of coordinates (path.shape[1])</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.mass">
<span class="sig-name descname"><span class="pre">mass</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the metric tensor M_{ij} along the path. The default is None,
in which case M_{ij} is treated as the identity matrix at all points</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.endpointSpringForce">
<span class="sig-name descname"><span class="pre">endpointSpringForce</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.endpointSpringForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether to turn on the endpoint spring force. Can be controlled for
both endpoints individually. If a list of bools, the elements
correspond to the first and the last endpoint. If a single bool, is applied
to both endpoints. The default is True.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool or list of bools</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.endpointHarmonicForce">
<span class="sig-name descname"><span class="pre">endpointHarmonicForce</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.endpointHarmonicForce" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as endpointSpringForce, except for the harmonic force term. Disabling
both forces keeps an endpoint fixed. The default is True.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool or list of bools</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.target_func">
<span class="sig-name descname"><span class="pre">target_func</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.target_func" title="Permalink to this definition">¶</a></dt>
<dd><p>The functional to be minimized. The default is utilities.TargetFunctions.action</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.target_func_grad">
<span class="sig-name descname"><span class="pre">target_func_grad</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.target_func_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximation of the gradient of target_func. The default is
utilities.GradientApproximations().forward_action_grad</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.logger">
<span class="sig-name descname"><span class="pre">logger</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls logging of the methods in this class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>instance of fileio.ForceLogger</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.nebParams">
<span class="sig-name descname"><span class="pre">nebParams</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.nebParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the spring and harmonic force strengths, and the energy
the endpoints are constrained to. Maintained for compatibility with
self.logger</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.k">
<span class="sig-name descname"><span class="pre">k</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.k" title="Permalink to this definition">¶</a></dt>
<dd><p>The spring force parameter</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.kappa">
<span class="sig-name descname"><span class="pre">kappa</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.kappa" title="Permalink to this definition">¶</a></dt>
<dd><p>The harmonic force parameter</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.constraintEneg">
<span class="sig-name descname"><span class="pre">constraintEneg</span></span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.constraintEneg" title="Permalink to this definition">¶</a></dt>
<dd><p>The energy the endpoints are constrained to</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.compute_force">
<span class="sig-name descname"><span class="pre">compute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.compute_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the net force at every point in points</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.LeastActionPath.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nPts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nDims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointSpringForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointHarmonicForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func_grad=&lt;bound</span> <span class="pre">method</span> <span class="pre">GradientApproximations.forward_action_grad</span> <span class="pre">of</span> <span class="pre">&lt;utilities.GradientApproximations</span> <span class="pre">object&gt;&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nebParams={}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loggerSettings={}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.LeastActionPath.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>potential</strong> (<em>function</em>) – Evaluates the energy along the path. To be called as potential(path).
Is passed to “target_func”.</p></li>
<li><p><strong>nPts</strong> (<em>int</em>) – The number of images in the path (path.shape[0])</p></li>
<li><p><strong>nDims</strong> (<em>int</em>) – The number of coordinates (path.shape[1])</p></li>
<li><p><strong>mass</strong> (<em>function</em><em>, </em><em>optional</em>) – Evaluates the metric tensor M_{ij} along the path. To be called as mass(path).
Is passed to “target_func”.The default is None, in which case $M_{ij}$
is treated as the identity matrix at all points</p></li>
<li><p><strong>endpointSpringForce</strong> (<em>bool</em><em> or </em><em>list of bools</em><em>, </em><em>optional</em>) – Whether to turn on the endpoint spring force. Can be controlled for
both endpoints individually. If a list of bools, the elements
correspond to the first and the last endpoint. If a single bool, is applied
to both endpoints. The default is True.</p></li>
<li><p><strong>endpointHarmonicForce</strong> (<em>bool</em><em> or </em><em>list of bools</em><em>, </em><em>optional</em>) – The same as endpointSpringForce, except for the harmonic force term. Disabling
both forces keeps an endpoint fixed. The default is True.</p></li>
<li><p><strong>target_func</strong> (<em>function</em><em>, </em><em>optional</em>) – The functional to be minimized. Should take as arguments
(path, potential, mass). Should return (action, potentialAtPath, massesAtPath).
The default is utilities.TargetFunctions.action</p></li>
<li><p><strong>target_func_grad</strong> (<em>function</em><em>, </em><em>optional</em>) – <dl class="simple">
<dt>The approximation of the gradient of target_func. Should take as arguments</dt><dd><p>(path, potentialFunc, potentialOnPath, massFunc, massOnPath, target_func),</p>
</dd>
</dl>
<p>where target_func is the action integral approximation. Should return
(gradOfAction, gradOfPes). The default is
utilities.GradientApproximations().forward_action_grad</p>
</p></li>
<li><p><strong>nebParams</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Contains the spring force and the harmonic oscillator potential parameters,
as well as the energy the endpoints are constrained to. The default is {},
in which case the parameters are</p>
<blockquote>
<div><p>{“k”:10,”kappa”:20,”constraintEneg”:0}</p>
</div></blockquote>
</p></li>
<li><p><strong>logLevel</strong> (<em>int</em><em>, </em><em>optional</em>) – Controls how much information is tracked. Level 0 turns off logging.
See fileio.ForceLogger, or a .lap file, for documentation on other
tracked information</p></li>
<li><p><strong>loggerSettings</strong> (<em>dict</em><em>, </em><em>optional</em>) – See fileio.ForceLogger for documentation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">compute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the net force along the path</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>np.ndarray</em>) – The path to evaluate the force along. Of shape (self.nPts,self.nDims)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>netForce</strong> – The force at each image on the path. Of shape (self.nPts,self.nDims)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.solvers.MinimumEnergyPath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.solvers.</span></span><span class="sig-name descname"><span class="pre">MinimumEnergyPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nPts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nDims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointSpringForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointHarmonicForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxFunc=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.mep_default&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func_grad=&lt;function</span> <span class="pre">potential_central_grad&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nebParams={}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loggerSettings={}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.MinimumEnergyPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Eric</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.MinimumEnergyPath.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nPts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nDims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointSpringForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpointHarmonicForce=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxFunc=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.mep_default&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func_grad=&lt;function</span> <span class="pre">potential_central_grad&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nebParams={}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loggerSettings={}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.MinimumEnergyPath.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>potential</strong> (<em>Function</em>) – To be called as potential(path). This is the PES function.
Is passed to “target_func”.</p></li>
<li><p><strong>endpointSpringForce</strong> (<em>Bool</em><em> or </em><em>tuple of bools</em>) – If a single bool, behavior is applied to both endpoints. If is a tuple
of bools, the first stands for the index 0 on the path; the second stands
for the index -1 on the path. TODO: possibly allow for a complicated
function that returns a bool?</p></li>
<li><p><strong>nPts</strong> (<em>Int</em>) – Number of points on the band, including endpoints.</p></li>
<li><p><strong>nDims</strong> (<em>Int</em>) – Number of dimensions of the collective coordinates. For instance,
when working with (Q20,Q30), nDims = 2.</p></li>
<li><p><strong>target_func</strong> (<em>Function</em><em>, </em><em>optional</em>) – The function to take the gradient of. Should take as arguments
(path, potential, AuxFunc). AuxFunc is used to add an optional potential to
modify the existing potential surface. This function should return
(potentialAtPath,AuxFuncAtPath). If no Aux function is needed,
input None for the argument and AuxFuncAtPath will be None. The default
is the PES potential (ie it just evaluates the potential).</p></li>
<li><p><strong>target_func_grad</strong> (<em>Function</em><em>, </em><em>optional</em>) – Approximate derivative of the target function evaluated at every point.
Should take as arguments points,potential,auxFunc)
where target_func is a potential target function . Should return
(gradOfPes, gradOfAux). If auxFunc is None, gradOfAux returns None</p></li>
<li><p><strong>nebParams</strong> (<em>Dict</em><em>, </em><em>optional</em>) – Keyword arguments for the nudged elastic band (NEB) method. Controls
the spring force and the harmonic oscillator potential. Default
parameters are controlled by a dictionary in the __init__ method.
The default is {}.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.MinimumEnergyPath.compute_force">
<span class="sig-name descname"><span class="pre">compute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.MinimumEnergyPath.compute_force" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.solvers.VerletMinimization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.solvers.</span></span><span class="sig-name descname"><span class="pre">VerletMinimization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nebObj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initialPoints</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.VerletMinimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Iterative algorithms for minimizing the force along a path, e.g. the least
action path, or a minimum energy path.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.VerletMinimization.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nebObj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initialPoints</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.VerletMinimization.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nebObj</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>initialPoints</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AttributeError</strong> – DESCRIPTION.</p></li>
<li><p><strong>ValueError</strong> – DESCRIPTION.</p></li>
</ul>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.VerletMinimization.fire">
<span class="sig-name descname"><span class="pre">fire</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fireParams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useLocal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">earlyStop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">earlyStopParams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">earlyAbort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">earlyAbortParams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.VerletMinimization.fire" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for fast inertial relaxation engine.
FIRE step taken from <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.97.170201">http://dx.doi.org/10.1103/PhysRevLett.97.170201</a></p>
<p>Velocity update taken from
<a class="reference external" href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet">https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet</a></p>
<p>TODO: consider making FIRE its own class, or allowing for attributes
like fireParams and etc
TODO: add maxmove parameter to prevent path exploding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tStep</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>maxIters</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>fireParams</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is {}.</p></li>
<li><p><strong>useLocal</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.VerletMinimization.fire2">
<span class="sig-name descname"><span class="pre">fire2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fireParams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useLocal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">earlyStop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">earlyStopParams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.VerletMinimization.fire2" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for fast inertial relaxation engine 2.
FIRE step taken from <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.97.170201">http://dx.doi.org/10.1103/PhysRevLett.97.170201</a></p>
<p>Velocity update taken from
<a class="reference external" href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet">https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tStep</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>maxIters</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>fireParams</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is {}.</p></li>
<li><p><strong>useLocal</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.solvers.VerletMinimization.velocity_verlet">
<span class="sig-name descname"><span class="pre">velocity_verlet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dampingParameter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.solvers.VerletMinimization.velocity_verlet" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements Algorithm 6 of <a class="reference external" href="https://doi.org/10.1021/acs.jctc.7b00360">https://doi.org/10.1021/acs.jctc.7b00360</a>
with optional damping force.</p>
<p>TODO: that paper has many errors, esp. off-by-one errors. Could lead
to issues. Consult <a class="reference external" href="http://dx.doi.org/10.1063/1.2841941">http://dx.doi.org/10.1063/1.2841941</a> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tStep</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>maxIters</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>dampingParameter</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>allPts</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>allVelocities</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>allForces</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyneb.utilities">
<span id="pyneb-utilities-module"></span><h2>pyneb.utilities module<a class="headerlink" href="#module-pyneb.utilities" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">GradientApproximations</span></span><a class="headerlink" href="#pyneb.utilities.GradientApproximations" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>When calling a method of GradientApproximations, we always supply a
target_func, such as TargetFunctions.action. However, sometimes we
only want the gradient wrt one term in the sum that makes up target_func.
So, we map target_func to a function that evaluates exactly one component
in the sum. This mapping is defined here.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>None.</em></p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.discrete_action_grad">
<span class="sig-name descname"><span class="pre">discrete_action_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.discrete_action_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs discretized action gradient, needs numerical PES still</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.discrete_action_grad_const">
<span class="sig-name descname"><span class="pre">discrete_action_grad_const</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.discrete_action_grad_const" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs discretized action gradient, needs numerical PES still</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.discrete_element">
<span class="sig-name descname"><span class="pre">discrete_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradOfPes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beffp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beffm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potm1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.discrete_element" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mass</strong> (<em>function</em>) – Callable mass function</p></li>
<li><p><strong>path</strong> (<em>float</em>) – Point i</p></li>
<li><p><strong>gradOfPes</strong> (<em>float array</em>) – Gradient of PES at point i</p></li>
<li><p><strong>dr</strong> (<em>float array</em>) – dr = r_i - r_i-1</p></li>
<li><p><strong>drp1</strong> (<em>float array</em>) – drp1 = r_i+1 - r_i</p></li>
<li><p><strong>beff</strong> (<em>float</em>) – Effective mass at point i</p></li>
<li><p><strong>beffp1</strong> (<em>float</em>) – Effective mass at point i+1</p></li>
<li><p><strong>beffm1</strong> (<em>float</em>) – Effective mass at point i-1</p></li>
<li><p><strong>pot</strong> (<em>float</em>) – Potential at point i.</p></li>
<li><p><strong>potp1</strong> (<em>float</em>) – Potential at point i+1</p></li>
<li><p><strong>potm1</strong> (<em>float</em>) – Potential at point i-1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradOfAction</strong> (<em>float array</em>) – Gradient of action at point i</p></li>
<li><p><em>Maintainer: Kyle</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.discrete_sqr_action_grad">
<span class="sig-name descname"><span class="pre">discrete_sqr_action_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.discrete_sqr_action_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs discretized action gradient, needs numerical PES still</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.discrete_sqr_action_grad_mp">
<span class="sig-name descname"><span class="pre">discrete_sqr_action_grad_mp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.discrete_sqr_action_grad_mp" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs discretized action gradient, needs numerical PES still</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.forward_action_component_grad">
<span class="sig-name descname"><span class="pre">forward_action_component_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.forward_action_component_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Requires an approximation of the action that just sums up values along
the path, such as TargetFunctions.action. Then, this computes the
forwards finite difference approximation of every <em>term in the sum</em>.</p>
<p>Note the difference with GradientApproximations().forward_action_grad:
there, the full action is computed for every step. Here, only the component
at that step is computed.</p>
<p>Does not return the gradient of the mass function, as that’s not used
elsewhere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>ndarray</em>) – The path. Of shape (nPoints,nDims)</p></li>
<li><p><strong>potential</strong> (<em>function.</em>) – Must take as input an array of shape path.shape</p></li>
<li><p><strong>potentialOnPath</strong> (<em>ndarray</em>) – Potential on the path. Of shape (nPoints,).</p></li>
<li><p><strong>mass</strong> (<em>function</em><em> or </em><em>None</em>) – </p></li>
<li><p><strong>massOnPath</strong> (<em>ndarray</em><em> or </em><em>None</em>) – Mass on path. If not None, of shape (nPoints,nDims,nDims).</p></li>
<li><p><strong>target_func</strong> (<em>function</em>) – Any term in TargetFunctions that is the sum of some constituent
terms (e.g. TargetFunctions.action). Uses target_func.__name__
to select the gradient of a term in the sum, such as
TargetFunctions.term_in_action_sum</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradOfAction</strong> (<em>ndarray</em>)</p></li>
<li><p><strong>gradOfPes</strong> (<em>ndarray</em>)</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.GradientApproximations.forward_action_grad">
<span class="sig-name descname"><span class="pre">forward_action_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.GradientApproximations.forward_action_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes forwards finite difference approx of any action-like function.
See e.g. TargetFunctions.action. Note that the full action is computed
at every finite difference step.</p>
<p>Does not return the gradient of the mass function, as that’s not used
elsewhere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>ndarray</em>) – The path. Of shape (nPoints,nDims)</p></li>
<li><p><strong>potential</strong> – As allowed in TargetFunctions.action</p></li>
<li><p><strong>potentialOnPath</strong> (<em>ndarray</em>) – Potential on the path. Of shape (nPoints,).</p></li>
<li><p><strong>mass</strong> – As allowed in TargetFunctions.action</p></li>
<li><p><strong>massOnPath</strong> (<em>ndarray</em><em> or </em><em>None</em>) – Mass on path. If not None, of shape (nPoints,nDims,nDims).</p></li>
<li><p><strong>target_func</strong> (<em>function</em>) – Function whose gradient is being computed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradOfAction</strong> (<em>ndarray</em>)</p></li>
<li><p><strong>gradOfPes</strong> (<em>ndarray</em>)</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.utilities.InterpolatedPath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">InterpolatedPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretePath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.InterpolatedPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.InterpolatedPath.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretePath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.InterpolatedPath.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Note that when one considers a 1D curve embedded in 2D, e.g. in a plot
of a function, one should specify ‘u’ in kwargs. Otherwise, ‘u’ will
be computed based on the distance between points on the path, which
will generally lead to a different plot than what is desired.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discretePath</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>kwargs</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is {}.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.InterpolatedPath.compute_along_path">
<span class="sig-name descname"><span class="pre">compute_along_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nImages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tfArgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tfKWargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.InterpolatedPath.compute_along_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.utilities.NDInterpWithBoundary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">NDInterpWithBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gridVals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryHandler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'exponential'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmExtend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformFuncName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splKWargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.NDInterpWithBoundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interpolates a grid in D dimensions, with extra handling for points outside
of the grid. The D&gt;2 case is based on scipy.interpolate.RegularGridInterpolator</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.NDInterpWithBoundary.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gridVals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryHandler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'exponential'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmExtend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformFuncName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'identity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splKWargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.NDInterpWithBoundary.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the class instance. Carries out basic error checking on inputs.
Defines self._call as the method to evaluate a point that’s within the
grid boundaries. It is also used in the boundary handlers, to evaluate
e.g. the nearest allowed point once it is found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gridPoints</strong> (<em>tuple of ndarrays</em>) – The unique grid points. Each array must be sorted in ascending order.</p></li>
<li><p><strong>gridVals</strong> (<em>ndarray</em>) – The grid values to be interpolated. Expected to be of shape (N2,N1,N3,…),
as in the output of np.meshgrid.</p></li>
<li><p><strong>boundaryHandler</strong> (<em>str</em><em>, </em><em>optional</em>) – How points outside of the interpolation region are handled. The
default is ‘exponential’.</p></li>
<li><p><strong>symmExtend</strong> (<em>bool</em><em> or </em><em>ndarray of bools</em><em>, </em><em>optional</em>) – Whether to symmetrically extend gridVals when evaluating. See notes.
The default is None.</p></li>
<li><p><strong>transformFuncName</strong> (<em>string</em><em>, </em><em>optional</em>) – The function to apply to the interpolated function after interpolating.
The default is “identity”, in which no post-processing is applied.</p></li>
<li><p><strong>splKWargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Extra arguments for spline interpolation, in the 2D case. The default
is {}.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The boundary handler is assumed to be the same for all dimensions, because
I can’t think of a reasonable way to allow for different handling for
different dimensions. I also see no reason why one would want to treat
the dimensions differently.</p>
<p>Our use case is density functional theory, and our grid points are the
multipole moments Qi in a constrained DFT calculation. It does not
always make sense to symmetrically extend a potential energy surface:
for Q30, it does, while for Q20, it does not. It also does not make sense
to symmetrically extend the PES at the maximum value. So, symmExtend by
default assumes Q30 is the second coordinate, and should only be extended
symmetrically near Q30 = 0; otherwise, everything else is not extended at
all.</p>
<p>Also assumes for symmetric extension that the lowest value is 0.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.utilities.PositiveSemidefInterpolator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">PositiveSemidefInterpolator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">listOfVals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndInterpKWargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.PositiveSemidefInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.PositiveSemidefInterpolator.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">listOfVals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndInterpKWargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.PositiveSemidefInterpolator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gridPoints</strong> (<em>tuple</em>) – <dl class="simple">
<dt>Elements are the unique coordinates of the grid. Shapes are</dt><dd><p>(N1,N2,…,Nn).</p>
</dd>
</dl>
</p></li>
<li><p><strong>listOfVals</strong> (<em>list</em>) – <dl class="simple">
<dt>A positive semidefinite matrix M has unique values</dt><dd><dl class="simple">
<dt>M = [[M00, M01, …, M0n],</dt><dd><p>[M01, M11, …, M1n],
…,
[M0n, M1n, …, Mnn]].</p>
</dd>
</dl>
</dd>
<dt>The components of listOfVals are the numpy arrays</dt><dd><p>[M00, M01, …, M0n, M11, M12, …, M1n, …, Mnn].</p>
</dd>
</dl>
<p>Each Mij is of shape (N2,N1,N3,…), as in the output of np.meshgrid.</p>
</p></li>
<li><p><strong>ndInterpKWargs</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is {}.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.utilities.SurfaceUtils">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">SurfaceUtils</span></span><a class="headerlink" href="#pyneb.utilities.SurfaceUtils" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Defined for namespace purposes</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.SurfaceUtils.find_all_local_maximum">
<span class="sig-name descname"><span class="pre">find_all_local_maximum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.SurfaceUtils.find_all_local_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices corresponding to the local maximum values. Taken
originally from <a class="reference external" href="https://stackoverflow.com/a/3986876">https://stackoverflow.com/a/3986876</a></p>
<p>Finder checks along the cardinal directions. If all neighbors in those
directions are greater than or equal to the current value, the index
is returned as a minimum. For the border, the array is reflected about
the axis. As a result, many indices are found that are not technically
local minima. However, we do want the border results - in practice,
nuclei often have a ground state at zero deformation in one collective
coordinate; to find that, we must include the border indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>Numpy array</em>) – A D-dimensional array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>maxIndsOut</strong> – D arrays of length k, for k maxima found</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple of numpy arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.SurfaceUtils.find_all_local_minimum">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_all_local_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.SurfaceUtils.find_all_local_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices corresponding to the local minimum values. Taken
originally from <a class="reference external" href="https://stackoverflow.com/a/3986876">https://stackoverflow.com/a/3986876</a></p>
<p>Finder checks along the cardinal directions. If all neighbors in those
directions are greater than or equal to the current value, the index
is returned as a minimum. For the border, the array is reflected about
the axis. As a result, many indices are found that are not technically
local minima. However, we do want the border results - in practice,
nuclei often have a ground state at zero deformation in one collective
coordinate; to find that, we must include the border indices. To exclude
them, one can then call SurfaceUtils.find_local_minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>Numpy array</em>) – A D-dimensional array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>minIndsOut</strong> – D arrays of length k, for k minima found</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple of numpy arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.SurfaceUtils.find_approximate_contours">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_approximate_contours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordMeshTuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.SurfaceUtils.find_approximate_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds 2D contours on a D-dimensional surface. Does so by considering
2D surfaces, using the first 2 indices of zz, and iterating over all other
indices. At every set of indices, pyplot.contour is called, to get the
2D contour(s) on the surface at that level. The contours are not filled
with the value of the coordinates with the other indices - i.e. each
segment is of shape (k,2), regardless of the number of dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coordMeshTuple</strong> (<em>tuple of ndarray</em>) – Coordinate mesh, e.g. output of np.meshgrid</p></li>
<li><p><strong>zz</strong> (<em>ndarray</em>) – Potential on mesh</p></li>
<li><p><strong>eneg</strong> (<em>float</em><em>, </em><em>optional</em>) – Energy of the desired contour. The default is 0.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to plot the contours. The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – Does not work for 1 dimension.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>allContours</strong> – Each element is the returned value of ax.contour.allsegs[0], i.e.
a list consisting of 2D arrays describing the contour on that slize
of zz</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray of lists</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.SurfaceUtils.find_endpoints_on_grid">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_endpoints_on_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordMeshTuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potArr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnAllPoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnIndices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.SurfaceUtils.find_endpoints_on_grid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>returnAllPoints</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is False.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>allowedEndpoints</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>allowedIndices</strong> (<em>TYPE</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.SurfaceUtils.find_local_minimum">
<span class="sig-name descname"><span class="pre">find_local_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">searchPerc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.25,</span> <span class="pre">0.25]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnOnlySmallest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.SurfaceUtils.find_local_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices corresponding to the local minimum values within a
desired part of the PES.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>Numpy array</em>) – A D-dimensional array.</p></li>
<li><p><strong>searchPerc</strong> (<em>List</em>) – Percentage of each coordinate that the minimum is allowed to be in.
See Notes for a note on searchPerc</p></li>
<li><p><strong>returnOnlySmallest</strong> (<em>Bool. Default is True</em>) – If True, returns only the (first) smallest value. If False, returns
all minima in the searched region.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>minIndsOut</strong> – D arrays of length k, for k minima found in the region. If returnOnlySmallest,
returns a tuple, not a tuple of arrays</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple of numpy arrays</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note that, if we write searchPerc=[s1,s2], then s1 is the range for
the first coordinate of arr. If arr was constructed to agree with
np.meshgrid’s default indexing, then s1 will actually restrict the
range of the second (physical) coordinate: np.meshgrid(X,Y,Z,…)
returns arrays of shape (Y.len,X.len,Z.len,…)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.SurfaceUtils.round_points_to_grid">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">round_points_to_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordMeshTuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptsArr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.SurfaceUtils.round_points_to_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds an array of points to the nearest point on a grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coordMeshTuple</strong> (<em>tuple of ndarrays</em>) – The grid. Taken as output of np.meshgrid</p></li>
<li><p><strong>ptsArr</strong> (<em>ndarray</em>) – The points to round. Of shape (nPoints,nDims), where nDims is the
number of coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>indsOut</strong> (<em>ndarray of ints</em>) – The indices of the points. Of shape (nPoints,nDims). See notes.</p></li>
<li><p><strong>gridValsOut</strong> (<em>ndarray</em>) – The nearest grid values. Of shape (nPoints,nDims).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Has standard complication from np.meshgrid - indexing is (N2,N1,N3,…),
when the coordinates have lengths (N1,N2,N3,…). This returns the default
indexing of np.meshgrid for coordMeshTuple. See e.g.
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html">https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html</a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyneb.utilities.TargetFunctions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">TargetFunctions</span></span><a class="headerlink" href="#pyneb.utilities.TargetFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.TargetFunctions.action">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.TargetFunctions.action" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: docs
Allowed masses:</p>
<blockquote>
<div><p>-Constant mass; set masses = None
-Array of values; set masses to a numpy array of shape (nPoints, nDims, nDims)
-A function; set masses to a function</p>
</div></blockquote>
<dl class="simple">
<dt>Allowed potential:</dt><dd><p>-Array of values; set potential to a numpy array of shape (nPoints,)
-A function; set masses to a function</p>
</dd>
<dt>Computes action as</dt><dd><p>$ S = sum_{i=1}^{nPoints} sqrt{2 E(x_i) M_{ab}(x_i) (x_i-x_{i-1})^a(x_i-x_{i-1})^b} $</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.TargetFunctions.action_squared">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">action_squared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.TargetFunctions.action_squared" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>ndarray</em>) – np.ndarray of shape (Nimgs,nDim) containing postions of all images.</p></li>
<li><p><strong>potential</strong> (<em>object</em><em> or </em><em>ndarray</em>) – Allowed potential:
-Array of values; set potential to a numpy array of shape (nPoints,)
-A function; set masses to a function</p></li>
<li><p><strong>masses</strong> (<em>object</em><em> or </em><em>ndarray</em><em>, </em><em>Optional</em>) – Allowed masses:
-Constant mass; set masses = None
-Array of values; set masses to a numpy array of shape (nPoints, nDims, nDims)
-A function; set masses to a function</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>actOut</strong> (<em>float</em>)</p></li>
<li><p><strong>potArr</strong> (<em>ndarray</em>) – ndarray of shape (Nimgs,1) containing the PES values for each image in path</p></li>
<li><p><strong>massArr</strong> (<em>ndarray</em>) – ndarray of shape (Nimgs,nDim,nDim) containing the mass tensors for each image in path.</p></li>
<li><p><em>Maintainer: Eric</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.TargetFunctions.mep_default">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mep_default</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxFunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.TargetFunctions.mep_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Essentially a wrapper function for the potential. Expected points to be
a (nPts,nDim) matrix. Potential should be a function capable of returning
a (nPts,nDim) matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>potential</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>auxFunc</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>energies</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>auxEnergies</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><em>Maintainer: Eric</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.TargetFunctions.term_in_action_squared_sum">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">term_in_action_squared_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.TargetFunctions.term_in_action_squared_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: docs
Allowed masses:</p>
<blockquote>
<div><p>-Constant mass; set masses = None
-Array of values; set masses to a numpy array of shape (nPoints, nDims, nDims)
-A function; set masses to a function</p>
</div></blockquote>
<dl class="simple">
<dt>Allowed potential:</dt><dd><p>-Array of values; set potential to a numpy array of shape (nPoints,)
-A function; set masses to a function</p>
</dd>
<dt>Computes action as</dt><dd><p>$ S = sum_{i=1}^{nPoints} sqrt{2 E(x_i) M_{ab}(x_i) (x_i-x_{i-1})^a(x_i-x_{i-1})^b} $</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyneb.utilities.TargetFunctions.term_in_action_sum">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">term_in_action_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.TargetFunctions.term_in_action_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: docs
Allowed masses:</p>
<blockquote>
<div><p>-Constant mass; set masses = None
-Array of values; set masses to a numpy array of shape (nPoints, nDims, nDims)
-A function; set masses to a function</p>
</div></blockquote>
<dl class="simple">
<dt>Allowed potential:</dt><dd><p>-Array of values; set potential to a numpy array of shape (nPoints,)
-A function; set masses to a function</p>
</dd>
<dt>Computes action as</dt><dd><p>$ S = sum_{i=1}^{nPoints} sqrt{2 E(x_i) M_{ab}(x_i) (x_i-x_{i-1})^a(x_i-x_{i-1})^b} $</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.utilities.beff_grad">
<span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">beff_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.beff_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Midpoint finite difference of B_eff mass.</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.utilities.get_crit_pnts">
<span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">get_crit_pnts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'central'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.get_crit_pnts" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING: This function depends on a package called autograd for hessian calculation
When using this function, you need to import numpy using: import autograd.numpy as np</p>
<p>This function finds the critical the MEP path must pass through by first finding the
critical points of the potential function evaluated along the curve and then classifies
using the eigenvalues of the Hessian. Returns minima, maxima, and saddle points indices
along the path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V_func</strong> (<em>object</em>) – Energy Function that must have shape (nImgs,nDims).</p></li>
<li><p><strong>path</strong> (<em>ndarray</em>) – coordinates of the path on the surface with shape (nImgs,nDims).</p></li>
<li><p><strong>method</strong> (<em>string</em>) – differentiation method option for numdifftools. Options are
‘central’, ‘complex’, ‘multicomplex’, ‘forward’, ‘backward’. See
<a class="reference external" href="https://numdifftools.readthedocs.io/en/latest/reference">https://numdifftools.readthedocs.io/en/latest/reference</a></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>3 arrays containing the indices of minima, maxima, and saddle points.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.utilities.mass_funcs_to_array_func">
<span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">mass_funcs_to_array_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictOfFuncs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uniqueKeys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.mass_funcs_to_array_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats a collection of functions for use in computing the inertia tensor.
Assumes the inertia tensor is symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dictOfFuncs</strong> (<em>dict</em>) – Contains functions for each component of the inertia tensor</p></li>
<li><p><strong>uniqueKeys</strong> (<em>list</em>) – <p>Labels the unique coordinates of the inertia tensor, in the order they
are used in the inertia. For instance, if one uses (q20, q30) as the
coordinates in this order, one should feed in [‘20’,’30’], and the
inertia will be reshaped as</p>
<blockquote>
<div><dl class="simple">
<dt>[[M_{20,20}, M_{20,30}]</dt><dd><p>[M_{30,20}, M_{30,30}]].</p>
</dd>
</dl>
</div></blockquote>
<p>Contrast this with feeding in [‘30’,’20’], in which the inertia will
be reshaped as</p>
<blockquote>
<div><dl class="simple">
<dt>[[M_{30,30}, M_{30,20}]</dt><dd><p>[M_{20,30}, M_{20,20}]].</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>func_out</strong> (<em>function</em>) – The inertia tensor. Can be called as func_out(coords).</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.utilities.midpoint_grad">
<span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">midpoint_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.midpoint_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: allow for arbitrary shaped outputs, for use with inertia tensor
TODO: maybe only have one gradient approx ever</p>
<dl class="simple">
<dt>Midpoint finite difference. Probably best if not used with actual DFT calculations,</dt><dd><p>vs a forwards/reverse finite difference</p>
</dd>
<dt>Assumes func only depends on a single point (vs the action, which depends on</dt><dd><p>all of the points)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Eric</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.utilities.potential_central_grad">
<span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">potential_central_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxFunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.potential_central_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in MEP for force updates. There, one only needs the gradient of the
PES.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>potential</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>auxFunc</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradPES</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>gradAux</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><em>Maintainer: Eric</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyneb.utilities.shift_func">
<span class="sig-prename descclassname"><span class="pre">pyneb.utilities.</span></span><span class="sig-name descname"><span class="pre">shift_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyneb.utilities.shift_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts func_in output down by shift. Especially for use with interpolators
where the minimum of the interpolator may be a bit lower than the minimum of
the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func_in</strong> (<em>function</em>) – </p></li>
<li><p><strong>shift</strong> (<em>float</em>) – The amount to shift by. The default is 10**(-4).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>func_out</strong> (<em>function</em>) – The shifted function</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyneb">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyneb" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">PyNEB</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022 PyNEB Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/source/pyneb.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>